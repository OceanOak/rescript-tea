// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var List = require("rescript/lib/js/list.js");
var $$Array = require("rescript/lib/js/array.js");
var Curry = require("rescript/lib/js/curry.js");
var Js_dict = require("rescript/lib/js/js_dict.js");
var Web_json = require("./web_json.js");
var Caml_array = require("rescript/lib/js/caml_array.js");
var Pervasives = require("rescript/lib/js/pervasives.js");
var Tea_result = require("./tea_result.js");
var Caml_option = require("rescript/lib/js/caml_option.js");
var Belt_MapString = require("rescript/lib/js/belt_MapString.js");
var Caml_exceptions = require("rescript/lib/js/caml_exceptions.js");
var Caml_js_exceptions = require("rescript/lib/js/caml_js_exceptions.js");

var ParseFail = /* @__PURE__ */Caml_exceptions.create("Tea_json.Decoder.ParseFail");

var string = /* Decoder */{
  _0: (function (value) {
      var s = Web_json.classify(value);
      if (typeof s === "number" || s.TAG !== /* JSONString */0) {
        return {
                TAG: /* Error */1,
                _0: "Non-string value"
              };
      } else {
        return {
                TAG: /* Ok */0,
                _0: s._0
              };
      }
    })
};

var $$int = /* Decoder */{
  _0: (function (value) {
      var n = Web_json.classify(value);
      if (typeof n === "number") {
        return {
                TAG: /* Error */1,
                _0: "Non-int value"
              };
      }
      if (n.TAG !== /* JSONNumber */1) {
        return {
                TAG: /* Error */1,
                _0: "Non-int value"
              };
      }
      var n$1 = n._0;
      if (n$1 > Pervasives.min_int && n$1 < Pervasives.max_int) {
        return {
                TAG: /* Ok */0,
                _0: n$1 | 0
              };
      } else {
        return {
                TAG: /* Error */1,
                _0: "number out of int range"
              };
      }
    })
};

var $$float = /* Decoder */{
  _0: (function (value) {
      var n = Web_json.classify(value);
      if (typeof n === "number" || n.TAG !== /* JSONNumber */1) {
        return {
                TAG: /* Error */1,
                _0: "Non-float-value"
              };
      } else {
        return {
                TAG: /* Ok */0,
                _0: n._0
              };
      }
    })
};

var bool = /* Decoder */{
  _0: (function (value) {
      var match = Web_json.classify(value);
      if (typeof match !== "number") {
        return {
                TAG: /* Error */1,
                _0: "Non-boolean value"
              };
      }
      switch (match) {
        case /* JSONFalse */0 :
            return {
                    TAG: /* Ok */0,
                    _0: false
                  };
        case /* JSONTrue */1 :
            return {
                    TAG: /* Ok */0,
                    _0: true
                  };
        case /* JSONNull */2 :
            return {
                    TAG: /* Error */1,
                    _0: "Non-boolean value"
                  };
        
      }
    })
};

function $$null(v) {
  return /* Decoder */{
          _0: (function (value) {
              var match = Web_json.classify(value);
              if (typeof match === "number" && match >= 2) {
                return {
                        TAG: /* Ok */0,
                        _0: v
                      };
              } else {
                return {
                        TAG: /* Error */1,
                        _0: "Non-null value"
                      };
              }
            })
        };
}

function list(decoder) {
  var decoder$1 = decoder._0;
  return /* Decoder */{
          _0: (function (value) {
              var a = Web_json.classify(value);
              if (typeof a === "number") {
                return {
                        TAG: /* Error */1,
                        _0: "Non-list value"
                      };
              }
              if (a.TAG !== /* JSONArray */3) {
                return {
                        TAG: /* Error */1,
                        _0: "Non-list value"
                      };
              }
              var parse = function (v) {
                var r = Curry._1(decoder$1, v);
                if (r.TAG === /* Ok */0) {
                  return r._0;
                }
                throw {
                      RE_EXN_ID: ParseFail,
                      _1: r._0,
                      Error: new Error()
                    };
              };
              try {
                return {
                        TAG: /* Ok */0,
                        _0: List.map(parse, $$Array.to_list(a._0))
                      };
              }
              catch (raw_e){
                var e = Caml_js_exceptions.internalToOCamlException(raw_e);
                if (e.RE_EXN_ID === ParseFail) {
                  return {
                          TAG: /* Error */1,
                          _0: "list -> " + e._1
                        };
                }
                throw e;
              }
            })
        };
}

function array(decoder) {
  var decoder$1 = decoder._0;
  return /* Decoder */{
          _0: (function (value) {
              var a = Web_json.classify(value);
              if (typeof a === "number") {
                return {
                        TAG: /* Error */1,
                        _0: "Non-array value"
                      };
              }
              if (a.TAG !== /* JSONArray */3) {
                return {
                        TAG: /* Error */1,
                        _0: "Non-array value"
                      };
              }
              var parse = function (v) {
                var r = Curry._1(decoder$1, v);
                if (r.TAG === /* Ok */0) {
                  return r._0;
                }
                throw {
                      RE_EXN_ID: ParseFail,
                      _1: r._0,
                      Error: new Error()
                    };
              };
              try {
                return {
                        TAG: /* Ok */0,
                        _0: $$Array.map(parse, a._0)
                      };
              }
              catch (raw_e){
                var e = Caml_js_exceptions.internalToOCamlException(raw_e);
                if (e.RE_EXN_ID === ParseFail) {
                  return {
                          TAG: /* Error */1,
                          _0: "array -> " + e._1
                        };
                }
                throw e;
              }
            })
        };
}

function keyValuePairs(decoder) {
  var decoder$1 = decoder._0;
  return /* Decoder */{
          _0: (function (value) {
              var o = Web_json.classify(value);
              if (typeof o === "number") {
                return {
                        TAG: /* Error */1,
                        _0: "Non-keyValuePair value"
                      };
              }
              if (o.TAG !== /* JSONObject */2) {
                return {
                        TAG: /* Error */1,
                        _0: "Non-keyValuePair value"
                      };
              }
              var o$1 = o._0;
              var keys = Object.keys(o$1);
              var parse = function (k, l) {
                var v = Js_dict.get(o$1, k);
                if (v !== undefined) {
                  var r = Curry._1(decoder$1, Caml_option.valFromOption(v));
                  if (r.TAG === /* Ok */0) {
                    return {
                            hd: [
                              k,
                              r._0
                            ],
                            tl: l
                          };
                  }
                  throw {
                        RE_EXN_ID: ParseFail,
                        _1: r._0,
                        Error: new Error()
                      };
                }
                throw {
                      RE_EXN_ID: ParseFail,
                      _1: "Key is undefined: " + k,
                      Error: new Error()
                    };
              };
              try {
                return {
                        TAG: /* Ok */0,
                        _0: $$Array.fold_right(parse, keys, /* [] */0)
                      };
              }
              catch (raw_e){
                var e = Caml_js_exceptions.internalToOCamlException(raw_e);
                if (e.RE_EXN_ID === ParseFail) {
                  return {
                          TAG: /* Error */1,
                          _0: "Invalid keyValuePair parsing: " + e._1
                        };
                }
                throw e;
              }
            })
        };
}

function dict(decoder) {
  var decoder$1 = decoder._0;
  return /* Decoder */{
          _0: (function (value) {
              var o = Web_json.classify(value);
              if (typeof o === "number") {
                return {
                        TAG: /* Error */1,
                        _0: "Non-dict value"
                      };
              }
              if (o.TAG !== /* JSONObject */2) {
                return {
                        TAG: /* Error */1,
                        _0: "Non-dict value"
                      };
              }
              var o$1 = o._0;
              var keys = Object.keys(o$1);
              var parse = function (k, d) {
                var v = Js_dict.get(o$1, k);
                if (v !== undefined) {
                  var r = Curry._1(decoder$1, Caml_option.valFromOption(v));
                  if (r.TAG === /* Ok */0) {
                    return Belt_MapString.set(d, k, r._0);
                  }
                  throw {
                        RE_EXN_ID: ParseFail,
                        _1: r._0,
                        Error: new Error()
                      };
                }
                throw {
                      RE_EXN_ID: ParseFail,
                      _1: "Key is undefined: " + k,
                      Error: new Error()
                    };
              };
              try {
                return {
                        TAG: /* Ok */0,
                        _0: $$Array.fold_right(parse, keys, undefined)
                      };
              }
              catch (raw_e){
                var e = Caml_js_exceptions.internalToOCamlException(raw_e);
                if (e.RE_EXN_ID === ParseFail) {
                  return {
                          TAG: /* Error */1,
                          _0: "Invalid dict parsing: " + e._1
                        };
                }
                throw e;
              }
            })
        };
}

function field(key, decoder) {
  var decoder$1 = decoder._0;
  return /* Decoder */{
          _0: (function (value) {
              var o = Web_json.classify(value);
              if (typeof o === "number") {
                return {
                        TAG: /* Error */1,
                        _0: "Non-fieldable value"
                      };
              }
              if (o.TAG !== /* JSONObject */2) {
                return {
                        TAG: /* Error */1,
                        _0: "Non-fieldable value"
                      };
              }
              var v = Js_dict.get(o._0, key);
              if (v === undefined) {
                return {
                        TAG: /* Error */1,
                        _0: "Field Value is undefined: " + key
                      };
              }
              var o$1 = Curry._1(decoder$1, Caml_option.valFromOption(v));
              if (o$1.TAG === /* Ok */0) {
                return o$1;
              } else {
                return {
                        TAG: /* Error */1,
                        _0: "field `" + (key + ("` -> " + o$1._0))
                      };
              }
            })
        };
}

function at(fields, dec) {
  return List.fold_right(field, fields, dec);
}

function index(idx, decoder) {
  var decoder$1 = decoder._0;
  return /* Decoder */{
          _0: (function (value) {
              var a = Web_json.classify(value);
              if (typeof a === "number") {
                return {
                        TAG: /* Error */1,
                        _0: "Non-array value"
                      };
              }
              if (a.TAG !== /* JSONArray */3) {
                return {
                        TAG: /* Error */1,
                        _0: "Non-array value"
                      };
              }
              var a$1 = a._0;
              if (idx < 0 || idx > a$1.length) {
                return {
                        TAG: /* Error */1,
                        _0: "Array index out of range: " + String(idx)
                      };
              } else {
                return Curry._1(decoder$1, Caml_array.get(a$1, idx));
              }
            })
        };
}

function maybe(decoder) {
  var decoder$1 = decoder._0;
  return /* Decoder */{
          _0: (function (value) {
              var r = Curry._1(decoder$1, value);
              if (r.TAG === /* Ok */0) {
                return {
                        TAG: /* Ok */0,
                        _0: Caml_option.some(r._0)
                      };
              } else {
                return {
                        TAG: /* Ok */0,
                        _0: undefined
                      };
              }
            })
        };
}

function oneOf(decoders) {
  return /* Decoder */{
          _0: (function (value) {
              var parse = function (v, _x) {
                while(true) {
                  var x = _x;
                  if (!x) {
                    return {
                            TAG: /* Error */1,
                            _0: "No one-of's matched"
                          };
                  }
                  var rest = x.tl;
                  try {
                    var ok = Curry._1(x.hd._0, v);
                    if (ok.TAG === /* Ok */0) {
                      return ok;
                    } else {
                      return parse(v, rest);
                    }
                  }
                  catch (exn){
                    _x = rest;
                    continue ;
                  }
                };
              };
              return parse(value, decoders);
            })
        };
}

function map(mapper, decoder1) {
  var decoder1$1 = decoder1._0;
  return /* Decoder */{
          _0: (function (value) {
              var v1 = Curry._1(decoder1$1, value);
              if (v1.TAG === /* Ok */0) {
                return {
                        TAG: /* Ok */0,
                        _0: Curry._1(mapper, v1._0)
                      };
              } else {
                return {
                        TAG: /* Error */1,
                        _0: "map " + v1._0
                      };
              }
            })
        };
}

function map2(mapper, decoder1, decoder2) {
  var decoder2$1 = decoder2._0;
  var decoder1$1 = decoder1._0;
  return /* Decoder */{
          _0: (function (value) {
              var match = Curry._1(decoder1$1, value);
              var match$1 = Curry._1(decoder2$1, value);
              if (match.TAG === /* Ok */0 && match$1.TAG === /* Ok */0) {
                return {
                        TAG: /* Ok */0,
                        _0: Curry._2(mapper, match._0, match$1._0)
                      };
              }
              var result;
              result = match$1.TAG === /* Ok */0 ? (
                  match.TAG === /* Ok */0 ? undefined : match._0
                ) : match$1._0;
              if (result !== undefined) {
                return {
                        TAG: /* Error */1,
                        _0: "map2 -> " + result
                      };
              }
              throw {
                    RE_EXN_ID: "Failure",
                    _1: "Impossible case",
                    Error: new Error()
                  };
            })
        };
}

function map3(mapper, decoder1, decoder2, decoder3) {
  var decoder3$1 = decoder3._0;
  var decoder2$1 = decoder2._0;
  var decoder1$1 = decoder1._0;
  return /* Decoder */{
          _0: (function (value) {
              var match = Curry._1(decoder1$1, value);
              var match$1 = Curry._1(decoder2$1, value);
              var match$2 = Curry._1(decoder3$1, value);
              if (match.TAG === /* Ok */0 && match$1.TAG === /* Ok */0 && match$2.TAG === /* Ok */0) {
                return {
                        TAG: /* Ok */0,
                        _0: Curry._3(mapper, match._0, match$1._0, match$2._0)
                      };
              }
              var e = Tea_result.first(match$2, Tea_result.first(match$1, match));
              if (e.TAG !== /* Ok */0) {
                return {
                        TAG: /* Error */1,
                        _0: "map3 -> " + e._0
                      };
              }
              throw {
                    RE_EXN_ID: "Failure",
                    _1: "Impossible case",
                    Error: new Error()
                  };
            })
        };
}

function map4(mapper, decoder1, decoder2, decoder3, decoder4) {
  var decoder4$1 = decoder4._0;
  var decoder3$1 = decoder3._0;
  var decoder2$1 = decoder2._0;
  var decoder1$1 = decoder1._0;
  return /* Decoder */{
          _0: (function (value) {
              var match = Curry._1(decoder1$1, value);
              var match$1 = Curry._1(decoder2$1, value);
              var match$2 = Curry._1(decoder3$1, value);
              var match$3 = Curry._1(decoder4$1, value);
              if (match.TAG === /* Ok */0 && match$1.TAG === /* Ok */0 && match$2.TAG === /* Ok */0 && match$3.TAG === /* Ok */0) {
                return {
                        TAG: /* Ok */0,
                        _0: Curry._4(mapper, match._0, match$1._0, match$2._0, match$3._0)
                      };
              }
              var e = Tea_result.first(match$3, Tea_result.first(match$2, Tea_result.first(match$1, match)));
              if (e.TAG !== /* Ok */0) {
                return {
                        TAG: /* Error */1,
                        _0: "map4 -> " + e._0
                      };
              }
              throw {
                    RE_EXN_ID: "Failure",
                    _1: "Impossible case",
                    Error: new Error()
                  };
            })
        };
}

function map5(mapper, decoder1, decoder2, decoder3, decoder4, decoder5) {
  var decoder5$1 = decoder5._0;
  var decoder4$1 = decoder4._0;
  var decoder3$1 = decoder3._0;
  var decoder2$1 = decoder2._0;
  var decoder1$1 = decoder1._0;
  return /* Decoder */{
          _0: (function (value) {
              var match = Curry._1(decoder1$1, value);
              var match$1 = Curry._1(decoder2$1, value);
              var match$2 = Curry._1(decoder3$1, value);
              var match$3 = Curry._1(decoder4$1, value);
              var match$4 = Curry._1(decoder5$1, value);
              if (match.TAG === /* Ok */0 && match$1.TAG === /* Ok */0 && match$2.TAG === /* Ok */0 && match$3.TAG === /* Ok */0 && match$4.TAG === /* Ok */0) {
                return {
                        TAG: /* Ok */0,
                        _0: Curry._5(mapper, match._0, match$1._0, match$2._0, match$3._0, match$4._0)
                      };
              }
              var e = Tea_result.first(match$4, Tea_result.first(match$3, Tea_result.first(match$2, Tea_result.first(match$1, match))));
              if (e.TAG !== /* Ok */0) {
                return {
                        TAG: /* Error */1,
                        _0: "map5 -> " + e._0
                      };
              }
              throw {
                    RE_EXN_ID: "Failure",
                    _1: "Impossible case",
                    Error: new Error()
                  };
            })
        };
}

function map6(mapper, decoder1, decoder2, decoder3, decoder4, decoder5, decoder6) {
  var decoder6$1 = decoder6._0;
  var decoder5$1 = decoder5._0;
  var decoder4$1 = decoder4._0;
  var decoder3$1 = decoder3._0;
  var decoder2$1 = decoder2._0;
  var decoder1$1 = decoder1._0;
  return /* Decoder */{
          _0: (function (value) {
              var match = Curry._1(decoder1$1, value);
              var match$1 = Curry._1(decoder2$1, value);
              var match$2 = Curry._1(decoder3$1, value);
              var match$3 = Curry._1(decoder4$1, value);
              var match$4 = Curry._1(decoder5$1, value);
              var match$5 = Curry._1(decoder6$1, value);
              if (match.TAG === /* Ok */0 && match$1.TAG === /* Ok */0 && match$2.TAG === /* Ok */0 && match$3.TAG === /* Ok */0 && match$4.TAG === /* Ok */0 && match$5.TAG === /* Ok */0) {
                return {
                        TAG: /* Ok */0,
                        _0: Curry._6(mapper, match._0, match$1._0, match$2._0, match$3._0, match$4._0, match$5._0)
                      };
              }
              var e = Tea_result.first(match$5, Tea_result.first(match$4, Tea_result.first(match$3, Tea_result.first(match$2, Tea_result.first(match$1, match)))));
              if (e.TAG !== /* Ok */0) {
                return {
                        TAG: /* Error */1,
                        _0: "map6 -> " + e._0
                      };
              }
              throw {
                    RE_EXN_ID: "Failure",
                    _1: "Impossible case",
                    Error: new Error()
                  };
            })
        };
}

function map7(mapper, decoder1, decoder2, decoder3, decoder4, decoder5, decoder6, decoder7) {
  var decoder7$1 = decoder7._0;
  var decoder6$1 = decoder6._0;
  var decoder5$1 = decoder5._0;
  var decoder4$1 = decoder4._0;
  var decoder3$1 = decoder3._0;
  var decoder2$1 = decoder2._0;
  var decoder1$1 = decoder1._0;
  return /* Decoder */{
          _0: (function (value) {
              var match = Curry._1(decoder1$1, value);
              var match$1 = Curry._1(decoder2$1, value);
              var match$2 = Curry._1(decoder3$1, value);
              var match$3 = Curry._1(decoder4$1, value);
              var match$4 = Curry._1(decoder5$1, value);
              var match$5 = Curry._1(decoder6$1, value);
              var match$6 = Curry._1(decoder7$1, value);
              if (match.TAG === /* Ok */0 && match$1.TAG === /* Ok */0 && match$2.TAG === /* Ok */0 && match$3.TAG === /* Ok */0 && match$4.TAG === /* Ok */0 && match$5.TAG === /* Ok */0 && match$6.TAG === /* Ok */0) {
                return {
                        TAG: /* Ok */0,
                        _0: Curry._7(mapper, match._0, match$1._0, match$2._0, match$3._0, match$4._0, match$5._0, match$6._0)
                      };
              }
              var e = Tea_result.first(match$6, Tea_result.first(match$5, Tea_result.first(match$4, Tea_result.first(match$3, Tea_result.first(match$2, Tea_result.first(match$1, match))))));
              if (e.TAG !== /* Ok */0) {
                return {
                        TAG: /* Error */1,
                        _0: "map7 -> " + e._0
                      };
              }
              throw {
                    RE_EXN_ID: "Failure",
                    _1: "Impossible case",
                    Error: new Error()
                  };
            })
        };
}

function map8(mapper, decoder1, decoder2, decoder3, decoder4, decoder5, decoder6, decoder7, decoder8) {
  var decoder8$1 = decoder8._0;
  var decoder7$1 = decoder7._0;
  var decoder6$1 = decoder6._0;
  var decoder5$1 = decoder5._0;
  var decoder4$1 = decoder4._0;
  var decoder3$1 = decoder3._0;
  var decoder2$1 = decoder2._0;
  var decoder1$1 = decoder1._0;
  return /* Decoder */{
          _0: (function (value) {
              var match = Curry._1(decoder1$1, value);
              var match$1 = Curry._1(decoder2$1, value);
              var match$2 = Curry._1(decoder3$1, value);
              var match$3 = Curry._1(decoder4$1, value);
              var match$4 = Curry._1(decoder5$1, value);
              var match$5 = Curry._1(decoder6$1, value);
              var match$6 = Curry._1(decoder7$1, value);
              var match$7 = Curry._1(decoder8$1, value);
              if (match.TAG === /* Ok */0 && match$1.TAG === /* Ok */0 && match$2.TAG === /* Ok */0 && match$3.TAG === /* Ok */0 && match$4.TAG === /* Ok */0 && match$5.TAG === /* Ok */0 && match$6.TAG === /* Ok */0 && match$7.TAG === /* Ok */0) {
                return {
                        TAG: /* Ok */0,
                        _0: Curry._8(mapper, match._0, match$1._0, match$2._0, match$3._0, match$4._0, match$5._0, match$6._0, match$7._0)
                      };
              }
              var e = Tea_result.first(match$7, Tea_result.first(match$6, Tea_result.first(match$5, Tea_result.first(match$4, Tea_result.first(match$3, Tea_result.first(match$2, Tea_result.first(match$1, match)))))));
              if (e.TAG !== /* Ok */0) {
                return {
                        TAG: /* Error */1,
                        _0: "map8 -> " + e._0
                      };
              }
              throw {
                    RE_EXN_ID: "Failure",
                    _1: "Impossible case",
                    Error: new Error()
                  };
            })
        };
}

function succeed(v) {
  return /* Decoder */{
          _0: (function (_value) {
              return {
                      TAG: /* Ok */0,
                      _0: v
                    };
            })
        };
}

function fail(e) {
  return /* Decoder */{
          _0: (function (_value) {
              return {
                      TAG: /* Error */1,
                      _0: e
                    };
            })
        };
}

var value = /* Decoder */{
  _0: (function (value) {
      return {
              TAG: /* Ok */0,
              _0: value
            };
    })
};

function andThen(func, decoder) {
  var decoder$1 = decoder._0;
  return /* Decoder */{
          _0: (function (value) {
              var r = Curry._1(decoder$1, value);
              if (r.TAG !== /* Ok */0) {
                return r;
              }
              var andThenDecoder = Curry._1(func, r._0);
              return Curry._1(andThenDecoder._0, value);
            })
        };
}

function lazy_(func) {
  return andThen(func, /* Decoder */{
              _0: (function (_value) {
                  return {
                          TAG: /* Ok */0,
                          _0: undefined
                        };
                })
            });
}

function nullable(decoder) {
  return oneOf({
              hd: $$null(undefined),
              tl: {
                hd: map((function (v) {
                        return Caml_option.some(v);
                      }), decoder),
                tl: /* [] */0
              }
            });
}

function decodeValue(decoder, value) {
  try {
    return Curry._1(decoder._0, value);
  }
  catch (raw_e){
    var e = Caml_js_exceptions.internalToOCamlException(raw_e);
    if (e.RE_EXN_ID === ParseFail) {
      return {
              TAG: /* Error */1,
              _0: e._1
            };
    } else {
      return {
              TAG: /* Error */1,
              _0: "Unknown JSON parsing error"
            };
    }
  }
}

function decodeEvent(decoder, value) {
  try {
    return Curry._1(decoder._0, value);
  }
  catch (raw_e){
    var e = Caml_js_exceptions.internalToOCamlException(raw_e);
    if (e.RE_EXN_ID === ParseFail) {
      return {
              TAG: /* Error */1,
              _0: e._1
            };
    } else {
      return {
              TAG: /* Error */1,
              _0: "Unknown JSON parsing error"
            };
    }
  }
}

function decodeString(decoder, string) {
  try {
    var value = JSON.parse(string);
    return decodeValue(decoder, value);
  }
  catch (exn){
    return {
            TAG: /* Error */1,
            _0: "Invalid JSON string"
          };
  }
}

function encode(indentLevel, value) {
  return Web_json.string_of_json(indentLevel, value);
}

function string$1(v) {
  return v;
}

function $$int$1(v) {
  return v;
}

function $$float$1(v) {
  return v;
}

function bool$1(v) {
  return v;
}

function object_(v) {
  var aux = function (o, param) {
    o[param[0]] = param[1];
    return o;
  };
  return List.fold_left(aux, {}, v);
}

function array$1(v) {
  return v;
}

var list$1 = $$Array.of_list;

var Encoder_null = null;

var Encoder = {
  encode: encode,
  string: string$1,
  $$int: $$int$1,
  $$float: $$float$1,
  bool: bool$1,
  $$null: Encoder_null,
  object_: object_,
  array: array$1,
  list: list$1
};

var Decoder_ObjectDict = {};

var Decoder = {
  ObjectDict: Decoder_ObjectDict,
  ParseFail: ParseFail,
  string: string,
  $$int: $$int,
  $$float: $$float,
  bool: bool,
  $$null: $$null,
  list: list,
  array: array,
  keyValuePairs: keyValuePairs,
  dict: dict,
  field: field,
  at: at,
  index: index,
  maybe: maybe,
  oneOf: oneOf,
  map: map,
  map2: map2,
  map3: map3,
  map4: map4,
  map5: map5,
  map6: map6,
  map7: map7,
  map8: map8,
  succeed: succeed,
  fail: fail,
  value: value,
  andThen: andThen,
  lazy_: lazy_,
  nullable: nullable,
  decodeValue: decodeValue,
  decodeEvent: decodeEvent,
  decodeString: decodeString
};

exports.Decoder = Decoder;
exports.Encoder = Encoder;
/* No side effect */
