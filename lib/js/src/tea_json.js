// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var $$Array = require("rescript/lib/js/array.js");
var Curry = require("rescript/lib/js/curry.js");
var Js_dict = require("rescript/lib/js/js_dict.js");
var Web_json = require("./web_json.js");
var Pervasives = require("rescript/lib/js/pervasives.js");
var Caml_option = require("rescript/lib/js/caml_option.js");
var Caml_exceptions = require("rescript/lib/js/caml_exceptions.js");
var Caml_js_exceptions = require("rescript/lib/js/caml_js_exceptions.js");

var ParseFail = /* @__PURE__ */Caml_exceptions.create("Tea_json.Decoder.ParseFail");

var $$int = /* Decoder */{
  _0: (function (value) {
      var n = Web_json.classify(value);
      if (typeof n === "number") {
        return {
                TAG: /* Error */1,
                _0: "Non-int value"
              };
      }
      if (n.TAG !== /* JSONNumber */1) {
        return {
                TAG: /* Error */1,
                _0: "Non-int value"
              };
      }
      var n$1 = n._0;
      if (n$1 > Pervasives.min_int && n$1 < Pervasives.max_int) {
        return {
                TAG: /* Ok */0,
                _0: n$1 | 0
              };
      } else {
        return {
                TAG: /* Error */1,
                _0: "number out of int range"
              };
      }
    })
};

function array(decoder) {
  var decoder$1 = decoder._0;
  return /* Decoder */{
          _0: (function (value) {
              var a = Web_json.classify(value);
              if (typeof a === "number") {
                return {
                        TAG: /* Error */1,
                        _0: "Non-array value"
                      };
              }
              if (a.TAG !== /* JSONArray */3) {
                return {
                        TAG: /* Error */1,
                        _0: "Non-array value"
                      };
              }
              var parse = function (v) {
                var r = Curry._1(decoder$1, v);
                if (r.TAG === /* Ok */0) {
                  return r._0;
                }
                throw {
                      RE_EXN_ID: ParseFail,
                      _1: r._0,
                      Error: new Error()
                    };
              };
              try {
                return {
                        TAG: /* Ok */0,
                        _0: $$Array.map(parse, a._0)
                      };
              }
              catch (raw_e){
                var e = Caml_js_exceptions.internalToOCamlException(raw_e);
                if (e.RE_EXN_ID === ParseFail) {
                  return {
                          TAG: /* Error */1,
                          _0: "array -> " + e._1
                        };
                }
                throw e;
              }
            })
        };
}

function field(key, decoder) {
  var decoder$1 = decoder._0;
  return /* Decoder */{
          _0: (function (value) {
              var o = Web_json.classify(value);
              if (typeof o === "number") {
                return {
                        TAG: /* Error */1,
                        _0: "Non-fieldable value"
                      };
              }
              if (o.TAG !== /* JSONObject */2) {
                return {
                        TAG: /* Error */1,
                        _0: "Non-fieldable value"
                      };
              }
              var v = Js_dict.get(o._0, key);
              if (v === undefined) {
                return {
                        TAG: /* Error */1,
                        _0: "Field Value is undefined: " + key
                      };
              }
              var o$1 = Curry._1(decoder$1, Caml_option.valFromOption(v));
              if (o$1.TAG === /* Ok */0) {
                return o$1;
              } else {
                return {
                        TAG: /* Error */1,
                        _0: "field `" + (key + ("` -> " + o$1._0))
                      };
              }
            })
        };
}

function map(mapper, decoder1) {
  var decoder1$1 = decoder1._0;
  return /* Decoder */{
          _0: (function (value) {
              var v1 = Curry._1(decoder1$1, value);
              if (v1.TAG === /* Ok */0) {
                return {
                        TAG: /* Ok */0,
                        _0: Curry._1(mapper, v1._0)
                      };
              } else {
                return {
                        TAG: /* Error */1,
                        _0: "map " + v1._0
                      };
              }
            })
        };
}

function map2(mapper, decoder1, decoder2) {
  var decoder2$1 = decoder2._0;
  var decoder1$1 = decoder1._0;
  return /* Decoder */{
          _0: (function (value) {
              var match = Curry._1(decoder1$1, value);
              var match$1 = Curry._1(decoder2$1, value);
              if (match.TAG === /* Ok */0 && match$1.TAG === /* Ok */0) {
                return {
                        TAG: /* Ok */0,
                        _0: Curry._2(mapper, match._0, match$1._0)
                      };
              }
              var result;
              result = match$1.TAG === /* Ok */0 ? (
                  match.TAG === /* Ok */0 ? undefined : match._0
                ) : match$1._0;
              if (result !== undefined) {
                return {
                        TAG: /* Error */1,
                        _0: "map2 -> " + result
                      };
              }
              throw {
                    RE_EXN_ID: "Failure",
                    _1: "Impossible case",
                    Error: new Error()
                  };
            })
        };
}

function succeed(v) {
  return /* Decoder */{
          _0: (function (_value) {
              return {
                      TAG: /* Ok */0,
                      _0: v
                    };
            })
        };
}

function decodeValue(decoder, value) {
  try {
    return Curry._1(decoder._0, value);
  }
  catch (raw_e){
    var e = Caml_js_exceptions.internalToOCamlException(raw_e);
    if (e.RE_EXN_ID === ParseFail) {
      return {
              TAG: /* Error */1,
              _0: e._1
            };
    } else {
      return {
              TAG: /* Error */1,
              _0: "Unknown JSON parsing error"
            };
    }
  }
}

function decodeEvent(decoder, value) {
  try {
    return Curry._1(decoder._0, value);
  }
  catch (raw_e){
    var e = Caml_js_exceptions.internalToOCamlException(raw_e);
    if (e.RE_EXN_ID === ParseFail) {
      return {
              TAG: /* Error */1,
              _0: e._1
            };
    } else {
      return {
              TAG: /* Error */1,
              _0: "Unknown JSON parsing error"
            };
    }
  }
}

function decodeString(decoder, string) {
  try {
    var value = JSON.parse(string);
    return decodeValue(decoder, value);
  }
  catch (exn){
    return {
            TAG: /* Error */1,
            _0: "Invalid JSON string"
          };
  }
}

var Decoder_ObjectDict = {};

var Decoder = {
  ObjectDict: Decoder_ObjectDict,
  ParseFail: ParseFail,
  $$int: $$int,
  array: array,
  field: field,
  map: map,
  map2: map2,
  succeed: succeed,
  decodeValue: decodeValue,
  decodeEvent: decodeEvent,
  decodeString: decodeString
};

exports.Decoder = Decoder;
/* No side effect */
